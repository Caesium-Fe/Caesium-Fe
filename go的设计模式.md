
https://blog.csdn.net/qq_44981657/article/details/107731130

# 设计模式

是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结

## 分类

创建型( 单例模式、简单工厂模式、工厂方法模式、抽象厂模式、建造者模式、原型模式)
结构型(代理模式、适配器模式、装饰模式、桥接模式、组合模式、享元模式、外观模式)
行为型(观察者模式、模板方法模式、命令模式、状态模式、职责链模式、解释器模式、中介者模式、访问者模式、策略模式、备忘录模式、迭代器模式)

## 五大原则

1、开闭原则
开放扩展，关闭修改
开闭原则的主旨是为了适应变化
使用开闭原则必须要软件设计合理，考虑到扩展与改变
2、但以功能原则
3、里氏替换原则
4、接口隔离原则
5、依赖反转原则
一、简单工厂模式
属于创建型模式，又叫做静态工厂方法.( Static Factory Method) 模式，但不属于23种GOF设计模式之一
在简单工厂模式中，可以根据参数的不同返回不同类的实例
简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
简单工厂模式的代码
https://github.com/jamkang/Design.git的01文件里面

优缺点
优点:实现了解耦

缺点:违背“开闭原则”

适合:创建的对象比较少

思路图


二、工厂方法模式
工厂方法模式又称为工厂模式，也叫虚拟构造器模式或者多态工厂模式，它属于类创建型模式
在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象
工厂方法模式代码
https://github.com/jamkang/Design.git的02文件里面

优缺点
优点:保持了简单工厂模式的优点，而且克服了它的缺点
缺点:在添加新产品时，在一定程度.上增加了系统的复杂度
适合:客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可
工厂模式适用的一些场景（不仅限于以下场景）：
对象的创建过程/实例化准备工作很复杂，需要初始化很多参数、查询数据库等。
类本身有好多子类，这些类的创建过程在业务中容易发生改变，或者对类的调用容易发生改变。
思路图


三、装饰模式
它是一种对象结构型模式
一种动态地往一个类中添加新的行为的设计模式
就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能
代码
https://github.com/jamkang/Design.git的03文件里面

优缺点
优点:
可以通过一种动态的方式来扩展一个对象的功能
可以使用多个具体装饰类来装饰同一对象，增加其功能
具体组件类与具体装饰类可以独立变化，符合“开闭原则”
缺点:
对于多次装饰的对象，易于出错，排错也很困难
对于产生很多具体装饰类 ，增加系统的复杂度以及理解成本
适合场景:
需要给一个对象增加功能，这些功能可以动态地撤销
需要给一批兄弟类增加或者改装功能
思路图


四、策略模式
策略模式是一种对象行为型模式
策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法
比如每个人都要“交个人所得税”但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法
代码
https://github.com/jamkang/Design.git的04文件里面

优缺点
优点:对“开闭原则”的完美支持
缺点:客户端必须知道所有策略类，并自己决定使用哪一个策略类
适合:一个系统需要动态地在几种算法或行为中选择一种
思维图


五、单例模式
单例模式要实现的效果就是，对于应用单例模式的类，整个程序中只存在一个实例化对象

代码
https://github.com/jamkang/Design.git的05文件里面

用途好处
一般使用于子需要创立一次，被多次使用的场景，如连接数据库

六、观察者模式
代码
https://github.com/jamkang/Design.git的06文件里面

优缺点
优点：

观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。
观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知，

缺点：

如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。
如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。

虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。