# 数据库

内连接就是普通的查询，例如

1.加inner join的：

```sql
SELECT     S.SName,C.CourseID,C.Grade
From         Sc AS C
INNER JOIN     Students AS S
ON         C.StudentID = S.SNo
```

2.不加inner join的

```sql
SELECT Students.SName, Sc.CourseID, Sc.Grade
FROM     Students,Sc
WHERE  Students.SNo = Sc.StudentID
```

外连接与普通连接的区别：

普通连接只输出满足连接条件的元组，外连接操作以指定表为连接主题，将主体表中不满足连接条件的元组一并输出。

外连接又分为左连接和右连接：

```mysql
左连接：SELECT     S.SName,C.CourseID,C.Grade
                From         Students AS S
                INNER JOIN     Sc AS C
                ON         C.StudentID <> S.SNo

​		       SELECT     S.SName,C.CourseID,C.Grade
​               From         Sc AS C
​               LEFT JOIN     Students AS S
​               ON         C.StudentID = S.SNo

sql排序--->以下是 SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据：

SELECT field1, field2,...fieldN FROM table_name1, table_name2...

ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]
```

你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。

你可以设定多个字段来排序。

你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。

你可以添加 WHERE...LIKE 子句来设置条件。

sql分组--->根据一个或多个列对结果集进行分组，function可以使用 COUNT, SUM, AVG,等函数。

```sql
SELECT column_name, function(column_name) FROM table_name

WHERE column_name operator value

GROUP BY column_name;

WITH ROLLUP可以随着group by一起使用，可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。

SELECT name, SUM(signin) as signin_count FROM  employee_tbl GROUP BY name WITH ROLLUP
```

注意以上查询语句会有NULL出现以表示总和计数

需要替换这个NULL可以配合使用Coalesce(),这个函数的作用为将该列中所有是NULL的值改为设定参数。

sql连接的使用--->

INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。

LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。

RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。

##  MySQL 事务

- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
- 事务用来管理 insert,update,delete 语句

一般来说，事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 事务控制语句：

- BEGIN 或 START TRANSACTION 显式地开启一个事务；
- COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
- ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
- SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
- RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
- ROLLBACK TO identifier 把事务回滚到标记点；
- SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

```mysql
mysql> use RUNOOB; 
Database changed 
mysql> CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表 
Query OK, 0 rows affected (0.04 sec)  
mysql> select * from runoob_transaction_test; 
Empty set (0.01 sec)  
mysql> begin;  # 开始事务 
Query OK, 0 rows affected (0.00 sec)  
mysql> insert into runoob_transaction_test value(5); 
Query OK, 1 rows affected (0.01 sec)  
mysql> insert into runoob_transaction_test value(6); 
Query OK, 1 rows affected (0.00 sec)  
mysql> commit; # 提交事务 
Query OK, 0 rows affected (0.01 sec)  
mysql>  select * from runoob_transaction_test; 
+------+
| id   |
+------+
| 5    |
| 6    |
+------+ 2 rows in set (0.01 sec)  
mysql> begin;    # 开始事务 
Query OK, 0 rows affected (0.00 sec)  
mysql>  insert into runoob_transaction_test values(7); 
Query OK, 1 rows affected (0.00 sec)  
mysql> rollback;   # 回滚 
Query OK, 0 rows affected (0.00 sec)  
mysql>   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入 
+------+ 
| id   | 
+------+ 
| 5    | 
| 6    |
+------+ 2 rows in set (0.01 sec)
```

如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。

```sql
ALTER TABLE testalter_tbl DROP i;
ALTER TABLE testalter_tbl ADD i INT FIRST;
ALTER TABLE testalter_tbl DROP i;
ALTER TABLE testalter_tbl ADD i INT AFTER c;
```

## 修改字段类型及名称

如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。

例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:

```sql
mysql> ALTER TABLE testalter_tbl MODIFY c CHAR(10);
```

使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：

```sql
mysql> ALTER TABLE testalter_tbl CHANGE i j BIGINT;
mysql> ALTER TABLE testalter_tbl CHANGE j j INT;
```

## ALTER TABLE 对 Null 值和默认值的影响

当你修改字段时，你可以指定是否包含值或者是否设置默认值。

以下实例，指定字段 j 为 NOT NULL 且默认值为100 。

```sql
mysql> ALTER TABLE testalter_tbl 
    -> MODIFY j BIGINT NOT NULL DEFAULT 100;
```

如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。

## alter其他用途：

修改存储引擎：修改为myisam

```sql
alter table tableName engine=myisam;
```

删除外键约束：keyName是外键别名

```sql
alter table tableName drop foreign key keyName;
```

修改字段的相对位置：这里name1为想要修改的字段，type1为该字段原来类型，first和after二选一，这应该显而易见，first放在第一位，after放在name2字段后面

```sql
alter table tableName modify name1 type1 first|after name2;
```

## 使用ALTER 命令添加和删除索引

有四种方式来添加数据表的索引：

- **ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):**该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。
- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。

