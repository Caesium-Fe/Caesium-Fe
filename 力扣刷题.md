### 1.求数组中两个数，相加等于目标值的坐标。

```go
func twoSum(nums []int, target int) []int {
    // 有求值数组  有结果值   找两个数坐标
    var a []int
    for i,v1 := range(nums){
        // 不能找自身，切片得往后移一位
        for j,v2:= range(nums[i+1:]){
            if sum := v1 + v2;sum == target{
                // fmt.Println(i, i+j)
                a = append(a, i)
                a = append(a, i+j+1)
                return a
            }
        }
    }
    return nil
}
```

### 2.求两个链表相加的结果也用链表返回。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func AddTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {

	// var tail *ListNode

	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	sum := l1.Val + l2.Val
	if sum > 9 {
		return &ListNode{
			Val:  sum - 10,
			Next: addTwoNumbers(&ListNode{Val: 1, Next: nil}, addTwoNumbers(l1.Next, l2.Next)),
		}
	} else {
		return &ListNode{
			Val:  sum,
			Next: addTwoNumbers(l1.Next, l2.Next),
		}
	}
}
```

### 3.无重复字符的最长子串

```python
# python找手感 老规矩
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        a = []
        max = 0
        # 这道题单层循环足矣
        for i in s:
            # 坑还是不少的 首先新建个列表存出现过的字符
            if i not in a:
                a.append(i)
               	# 记录到具有重复字符时，列表里元素的个数
                d = len(a)
            else:
                # 另一个坑，重复的两个字符中间的子串可能后续并不会出现重复值，所以不能舍弃
                j = a.index(i)
                # a = []
                a = a[j+1:]
                a.append(i)
                d = len(a)
        if d > max:
            max = d
        return max
```

```go
// 通过python思路来写的算法，可能不是很好，有待优化
func lengthOfLongestSubstring(s string) int {
    // a := make([]string, 128, 128)
    d, max := 0, 0
    t := ""
    for _, i := range(s){
        if j := strings.Index(t,string(i));j == -1{
            // a = append(a, i)
            t += string(i)
            d = len(t)
        }else{
            t = t[j+1:]
            t += string(i)
            d = len(t)
        }
        if d > max{
            max = d
        }
    }
    return max
}

//尝试优化代码
func lengthOfLongestSubstring(s string) int {
    // a := make([]string, 128, 128)
    d, max := 0, 0
    t := ""
    for _, i := range(s){
        // 查找字串中的index
        if j := strings.Index(t,string(i));j != -1{
            t = t[j+1:]
        }
        t += string(i)
        d = len(t)
        if d > max{
            max = d
        }
    }
    return max
}

//优化前后代码执行时间下降，但内存消耗任然居高，下一次优化内存分配
```

### 4.寻找两个正序数组的中位数

```go
// 由于这题要求的时间复杂度在O(log(m+n))，那么两层循环的解法显然不行
// 那么就从每次一个移动，变成二分查找题目来写
// 找出第k小的数
// 但这里有个新问题就是 奇数 和 偶数 个的数组的中位数组成不同
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	totalLength := len(nums1) + len(nums2)
	if totalLength%2 == 1 {
		midIndex := totalLength / 2
		return float64(getKthElement(nums1, nums2, midIndex+1))
	} else {
		midIndex1, midIndex2 := totalLength/2-1, totalLength/2
		return float64(getKthElement(nums1, nums2, midIndex1+1)+getKthElement(nums1, nums2, midIndex2+1)) / 2.0
	}
	return 0
}

func getKthElement(nums1, nums2 []int, k int) int {
	index1, index2 := 0, 0
	for {
		if index1 == len(nums1) {
			return nums2[index2+k-1]
		}
		if index2 == len(nums2) {
			return nums1[index1+k-1]
		}
		if k == 1 {
			return min(nums1[index1], nums2[index2])
		}
		half := k / 2
		newIndex1 := min(index1+half, len(nums1)) - 1
		newIndex2 := min(index2+half, len(nums2)) - 1
		pivot1, pivot2 := nums1[newIndex1], nums2[newIndex2]
		if pivot1 <= pivot2 {
			k -= (newIndex1 - index1 + 1)
			index1 = newIndex1 + 1
		} else {
			k -= (newIndex2 - index2 + 1)
			index2 = newIndex2 + 1
		}
	}
	return 0
}

func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}
```

### 5.求最长回文子串

```go
// 回文也会遇到字符串的奇偶个数问题
// 那么在每个字符中间添加一个特殊字符来进行补充，就可以避开这个问题
func LongestPalindrome(s string) string {
	t := "#"
	for i := 0; i < len(s); i++ {
		t += string(s[i]) + "#"
	}
	// t += "#"
	// return t
	// 存储最长回文字符串
	ans := ""
	for i := 0; i < len(t); i++ {
		j := 1
		now := ""
		for {
			// if s[i] == "#"{
			//     break
			// }
			right := j + i
			left := i - j
			if (left >= 0) && (right < len(t)) {
				// if (string(t[left]) == "#") || (string(t[right]) == "#") {
				// 	j++
				// 	continue
				// }
				if t[left] == t[right] {
					j++
					now = t[left : right+1]
					fmt.Println(now)
					if len(now) > len(ans) {
						ans = now
					}
				} else {
					break
				}
			} else {
				break
			}
		}
	}
	now := ""
	for i := 0; i < len(ans); i++ {
		if ans[i] != '#' {
			now += string(ans[i])
		}
	}
	return now
}

```
