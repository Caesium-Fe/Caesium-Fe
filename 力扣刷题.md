### 1.求数组中两个数，相加等于目标值的坐标。

```go
func twoSum(nums []int, target int) []int {
    // 有求值数组  有结果值   找两个数坐标
    var a []int
    for i,v1 := range(nums){
        // 不能找自身，切片得往后移一位
        for j,v2:= range(nums[i+1:]){
            if sum := v1 + v2;sum == target{
                // fmt.Println(i, i+j)
                a = append(a, i)
                a = append(a, i+j+1)
                return a
            }
        }
    }
    return nil
}
```

### 2.求两个链表相加的结果也用链表返回。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func AddTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {

	// var tail *ListNode

	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	sum := l1.Val + l2.Val
	if sum > 9 {
		return &ListNode{
			Val:  sum - 10,
			Next: addTwoNumbers(&ListNode{Val: 1, Next: nil}, addTwoNumbers(l1.Next, l2.Next)),
		}
	} else {
		return &ListNode{
			Val:  sum,
			Next: addTwoNumbers(l1.Next, l2.Next),
		}
	}
}
```

### 3.无重复字符的最长子串

```python
# python找手感 老规矩
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        a = []
        max = 0
        # 这道题单层循环足矣
        for i in s:
            # 坑还是不少的 首先新建个列表存出现过的字符
            if i not in a:
                a.append(i)
               	# 记录到具有重复字符时，列表里元素的个数
                d = len(a)
            else:
                # 另一个坑，重复的两个字符中间的子串可能后续并不会出现重复值，所以不能舍弃
                j = a.index(i)
                # a = []
                a = a[j+1:]
                a.append(i)
                d = len(a)
        if d > max:
            max = d
        return max
```

```go
// 通过python思路来写的算法，可能不是很好，有待优化
func lengthOfLongestSubstring(s string) int {
    // a := make([]string, 128, 128)
    d, max := 0, 0
    t := ""
    for _, i := range(s){
        if j := strings.Index(t,string(i));j == -1{
            // a = append(a, i)
            t += string(i)
            d = len(t)
        }else{
            t = t[j+1:]
            t += string(i)
            d = len(t)
        }
        if d > max{
            max = d
        }
    }
    return max
}

//尝试优化代码
func lengthOfLongestSubstring(s string) int {
    // a := make([]string, 128, 128)
    d, max := 0, 0
    t := ""
    for _, i := range(s){
        // 查找字串中的index
        if j := strings.Index(t,string(i));j != -1{
            t = t[j+1:]
        }
        t += string(i)
        d = len(t)
        if d > max{
            max = d
        }
    }
    return max
}

//优化前后代码执行时间下降，但内存消耗任然居高，下一次优化内存分配
```

### 4.寻找两个正序数组的中位数

